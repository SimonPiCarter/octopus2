#include <gtest/gtest.h>

#include "octopus/commands/basic/NoOpCommand.hh" // For variant queue
#include "octopus/commands/basic/rally_point/SetRallyPointCommand.hh"
#include "octopus/commands/queue/CommandQueue.hh"
#include "octopus/components/basic/position/Position.hh"
#include "octopus/components/basic/rally_point/RallyPoint.hh"
#include "octopus/components/step/Step.hh"
#include "octopus/components/step/StepContainer.hh" // For StepContext internals
#include "octopus/systems/Systems.hh"
#include "octopus/world/WorldContext.hh"
#include "octopus/world/StepContext.hh"

using namespace octopus;

// Define a CommandQueue type that can hold SetRallyPointCommand and NoOpCommand
using RallyPointTestCommandVariant = std::variant<NoOpCommand, SetRallyPointCommand>;
using RallyPointTestCommandQueue = CommandQueue<RallyPointTestCommandVariant>;

// Define the StepContainer type that will be used in StepContext
// It needs to include RallyPointStep and any other steps potentially generated by default systems.
// For this test, focusing on RallyPointStep. Other steps like PositionStep might be relevant
// if other systems (like move systems) were active, but here we isolate RallyPointCommand.
using TestStepContainer = StepContainerCascade<RallyPointStep, PositionStep, HitPointStep, HitPointMaxStep, CommandStateStep<RallyPointTestCommandVariant::idx<SetRallyPointCommand>()> >;


TEST(SetRallyPointCommandTest, TargetMatchesPosition)
{
    WorldContext world_l;
    flecs::world &ecs_l = world_l.ecs;

    // Register components
    ecs_l.component<Position>();
    ecs_l.component<RallyPoint>();
    ecs_l.component<RallyPointTestCommandQueue>();
    ecs_l.component<SetRallyPointCommand::State>(); // State for the command itself
    ecs_l.component<NoOpCommand::State>();          // State for NoOpCommand in variant

    StepContext stepContext_l = makeCustomStepContext<TestStepContainer, RallyPointTestCommandVariant>();

    // Basic systems setup
    set_up_systems(world_l, stepContext_l);
    // Setup specific system for SetRallyPointCommand
    set_up_rally_point_command_system(ecs_l, stepContext_l.steps);

    // Create an entity
    auto entity_l = ecs_l.entity()
        .set<Position>({{10., 5.}, {0., 0.}, 1., 0.5, true}) // Initial position
        .add<RallyPointTestCommandQueue>();

    // Create SetRallyPointCommand with target same as entity position
    SetRallyPointCommand cmd_l;
    cmd_l.rally_point.target = Vector {10., 5.};
    cmd_l.rally_point.enabled = true;
    cmd_l.rally_point.tolerance = 2.;

    RallyPointTestCommandQueue* cq_mut_l = entity_l.get_mut<RallyPointTestCommandQueue>();
    ASSERT_NE(nullptr, cq_mut_l);
    cq_mut_l->_queuedActions.push_back(CommandQueueActionAddBack<RallyPointTestCommandVariant>{cmd_l});

    // Progress the world
    ecs_l.progress();

    // Assertions
    // Check RallyPointStep
    const auto& rally_point_steps_l = stepContext_l.steps.get<RallyPointStep>().steps;
    ASSERT_EQ(1u, rally_point_steps_l.size());
    const auto& step_data_l = rally_point_steps_l.at(0).step.new_rally_point;

    EXPECT_DOUBLE_EQ(10., step_data_l.target.x.to_double());
    EXPECT_DOUBLE_EQ(5., step_data_l.target.y.to_double());
    EXPECT_DOUBLE_EQ(0., step_data_l.tolerance.to_double()); // Special case from system: tolerance 0
    EXPECT_FALSE(step_data_l.enabled);                        // Special case from system: enabled false

    // Check CommandQueue is done
    const auto* cq_after_l = entity_l.get<RallyPointTestCommandQueue>();
    ASSERT_NE(nullptr, cq_after_l);
    ASSERT_TRUE(cq_after_l->isLastCommandDone());
    ASSERT_TRUE(cq_after_l->_queuedActions.empty());
}

TEST(SetRallyPointCommandTest, TargetDiffersFromPosition)
{
    WorldContext world_l;
    flecs::world &ecs_l = world_l.ecs;

    // Register components
    ecs_l.component<Position>();
    ecs_l.component<RallyPoint>();
    ecs_l.component<RallyPointTestCommandQueue>();
    ecs_l.component<SetRallyPointCommand::State>();
    ecs_l.component<NoOpCommand::State>();

    StepContext stepContext_l = makeCustomStepContext<TestStepContainer, RallyPointTestCommandVariant>();

    set_up_systems(world_l, stepContext_l);
    set_up_rally_point_command_system(ecs_l, stepContext_l.steps);

    auto entity_l = ecs_l.entity()
        .set<Position>({{10., 5.}, {0., 0.}, 1., 0.5, true})
        .add<RallyPointTestCommandQueue>();

    // Create SetRallyPointCommand with target different from entity position
    SetRallyPointCommand cmd_l;
    cmd_l.rally_point.target = Vector {20., 15.};
    cmd_l.rally_point.enabled = true;
    cmd_l.rally_point.tolerance = 3.;

    RallyPointTestCommandQueue* cq_mut_l = entity_l.get_mut<RallyPointTestCommandQueue>();
    ASSERT_NE(nullptr, cq_mut_l);
    cq_mut_l->_queuedActions.push_back(CommandQueueActionAddBack<RallyPointTestCommandVariant>{cmd_l});

    ecs_l.progress();

    const auto& rally_point_steps_l = stepContext_l.steps.get<RallyPointStep>().steps;
    ASSERT_EQ(1u, rally_point_steps_l.size());
    const auto& step_data_l = rally_point_steps_l.at(0).step.new_rally_point;

    EXPECT_DOUBLE_EQ(20., step_data_l.target.x.to_double());
    EXPECT_DOUBLE_EQ(15., step_data_l.target.y.to_double());
    EXPECT_DOUBLE_EQ(3., step_data_l.tolerance.to_double()); // Uses command's tolerance
    EXPECT_TRUE(step_data_l.enabled);                       // Uses command's enabled state

    const auto* cq_after_l = entity_l.get<RallyPointTestCommandQueue>();
    ASSERT_NE(nullptr, cq_after_l);
    ASSERT_TRUE(cq_after_l->isLastCommandDone());
    ASSERT_TRUE(cq_after_l->_queuedActions.empty());
}
